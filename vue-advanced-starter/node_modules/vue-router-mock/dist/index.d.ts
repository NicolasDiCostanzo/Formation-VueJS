import * as vue_router from 'vue-router';
import { Router, RouteLocationRaw, RouteParamsRaw, LocationQueryRaw, RouterOptions, RouteLocationNormalizedLoaded } from 'vue-router';
import * as vue from 'vue';
import { Ref } from 'vue';
import { VueWrapper } from '@vue/test-utils';

/**
 * Options passed to the `spy` option of the `createRouterMock` function
 */
interface RouterMockSpyOptions {
    /**
     * Creates a spy (for example, `create: fn => vi.fn(fn)` with vitest)
     */
    create: (...args: any[]) => any;
    /**
     * Resets a spy but keeps it active.
     */
    reset: (spy: _InferSpyType) => void;
}
/**
 * Define your own Spy to adapt to your testing framework (jest, peeky, sinon, vitest, etc)
 * @beta: still trying out, could change in the future
 *
 * @example
 * ```ts
 * import 'vue-router-mock' // Only needed on external d.ts files
 *
 * declare module 'vue-router-mock' {
 *   export interface RouterMockSpy<Fn> {
 *     spy: Sinon.Spy<Parameters<Fn>, ReturnType<Fn>>
 *   }
 * }
 * ```
 */
interface RouterMockSpy<Fn extends (...args: any[]) => any = (...args: any[]) => any> {
}
/**
 * @internal
 */
type _InferSpyType<Fn extends (...args: any[]) => any = (...args: any[]) => any> = keyof RouterMockSpy<Fn> extends 'spy' ? RouterMockSpy<Fn>['spy'] : Fn;

declare const EmptyView: vue.DefineComponent<{}, {}, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{}>>, {}, {}>;
/**
 * Router Mock instance
 */
interface RouterMock extends Router {
    /**
     * Current depth of the router view. This index is used to find the component
     * to display in the array `router.currentRoute.value.matched`.
     */
    depth: Ref<number>;
    /**
     * Set a value to be returned on a navigation guard for the next navigation.
     *
     * @param returnValue - value that will be returned on a simulated navigation
     * guard
     */
    setNextGuardReturn(returnValue: Error | boolean | RouteLocationRaw | undefined): void;
    /**
     * Returns a Promise of the pending navigation. Resolves right away if there
     * isn't any.
     */
    getPendingNavigation(): ReturnType<Router['push']>;
    /**
     * Sets the params of the current route without triggering a navigation. Can
     * be awaited to wait for Vue to render again.
     *
     * @param params - params to set in the current route
     */
    setParams(params: RouteParamsRaw): Promise<void>;
    /**
     * Sets the query of the current route without triggering a navigation. Can
     * be awaited to wait for Vue to render again.
     *
     * @param query - query to set in the current route
     */
    setQuery(query: LocationQueryRaw): Promise<void>;
    /**
     * Sets the hash of the current route without triggering a navigation. Can
     * be awaited to wait for Vue to render again.
     *
     * @param hash - hash to set in the current route
     */
    setHash(hash: string): Promise<void>;
    /**
     * Clear all the mocks and reset the location of the router. This is useful to be called in a `beforeEach()` test hook
     * to reset the router state before each test.
     */
    reset(): void;
    push: _InferSpyType<Router['push']>;
    replace: _InferSpyType<Router['replace']>;
}
/**
 * Options passed to `createRouterMock()`.
 */
interface RouterMockOptions extends Partial<RouterOptions> {
    /**
     * Override the starting location before each test. Defaults to
     * START_LOCATION.
     */
    initialLocation?: RouteLocationRaw;
    /**
     * Run in-component guards. Defaults to false. Setting this to `true` will also run global guards as if
     * `useRealNavigation` was set to `true`.
     */
    runInComponentGuards?: boolean;
    /**
     * Runs all navigation through a `push()` or `replace()` to effectively run any global.
     */
    useRealNavigation?: boolean;
    /**
     * Run per-route guards. Defaults to false.
     * @deprecated use `removePerRouteGuards` instead
     */
    runPerRouteGuards?: boolean;
    /**
     * Removes `beforeEnter` guards to any route added. Defaults to `true`.
     */
    removePerRouteGuards?: boolean;
    /**
     * By default the mock will allow you to push to locations without adding all
     * the necessary routes so you can still check if `router.push()` was called
     * in a specific scenario
     * (https://github.com/posva/vue-router-mock/issues/41). Set this to `true` to
     * disable that behavior and throw when `router.push()` fails.
     */
    noUndeclaredRoutes?: boolean;
    /**
     * By default the mock will use sinon, jest, or vitest support to create and reset spies. This option allows to use
     * any testing library with its own spies, by providing a method to create spies, and one to reset them them. Check
     * the `RouterMockSpy` type to add your own type.
     *
     * @example
     *
     * For example, with vitest with `globals: false`:
     *
     * ```ts
     * const router = createRouterMock({
     *   spy: {
     *     create: fn => vi.fn(fn),
     *     reset: spy => spy.mockClear()
     *   }
     * });
     * ```
     */
    spy?: RouterMockSpyOptions;
}
/**
 * Creates a router mock instance
 *
 * @param options - options to initialize the router
 */
declare function createRouterMock(options?: RouterMockOptions): RouterMock;

/**
 * Inject global variables, overriding any previously inject router mock
 *
 * @param router - router mock to inject
 */
declare function injectRouterMock(router?: RouterMock): {
    router: RouterMock;
    route: RouteLocationNormalizedLoaded;
};
/**
 * Creates an object of properties to be provided at your application level to
 * mock what is injected by vue-router
 *
 * @param router - router mock instance
 */
declare function createProvide(router: RouterMock): {
    [x: number]: RouteLocationNormalizedLoaded | vue.Ref<RouteLocationNormalizedLoaded> | RouterMock | vue.ComputedRef<vue_router.RouteLocationMatched>;
};

declare function plugin(wrapper: VueWrapper): VueWrapper<unknown, {
    $: vue.ComponentInternalInstance;
    $data: {};
    $props: {};
    $attrs: {
        [x: string]: unknown;
    };
    $refs: {
        [x: string]: unknown;
    };
    $slots: Readonly<{
        [name: string]: vue.Slot<any> | undefined;
    }>;
    $root: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}> | null;
    $parent: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}> | null;
    $emit: (event: string, ...args: any[]) => void;
    $el: any;
    $options: vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}> & {
        beforeCreate?: ((() => void) | (() => void)[]) | undefined;
        created?: ((() => void) | (() => void)[]) | undefined;
        beforeMount?: ((() => void) | (() => void)[]) | undefined;
        mounted?: ((() => void) | (() => void)[]) | undefined;
        beforeUpdate?: ((() => void) | (() => void)[]) | undefined;
        updated?: ((() => void) | (() => void)[]) | undefined;
        activated?: ((() => void) | (() => void)[]) | undefined;
        deactivated?: ((() => void) | (() => void)[]) | undefined;
        beforeDestroy?: ((() => void) | (() => void)[]) | undefined;
        beforeUnmount?: ((() => void) | (() => void)[]) | undefined;
        destroyed?: ((() => void) | (() => void)[]) | undefined;
        unmounted?: ((() => void) | (() => void)[]) | undefined;
        renderTracked?: (((e: vue.DebuggerEvent) => void) | ((e: vue.DebuggerEvent) => void)[]) | undefined;
        renderTriggered?: (((e: vue.DebuggerEvent) => void) | ((e: vue.DebuggerEvent) => void)[]) | undefined;
        errorCaptured?: (((err: unknown, instance: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}> | null, info: string) => boolean | void) | ((err: unknown, instance: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}> | null, info: string) => boolean | void)[]) | undefined;
    };
    $forceUpdate: () => void;
    $nextTick: typeof vue.nextTick;
    $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: vue.WatchOptions<boolean> | undefined): vue.WatchStopHandle;
} & Omit<{}, never> & vue.ShallowUnwrapRef<{}> & {} & vue.ComponentCustomProperties & {}>;
declare function getRouter(): RouterMock;
declare module '@vue/test-utils' {
    interface VueWrapper<VM, T> {
        router: RouterMock;
    }
}

export { EmptyView, type RouterMock, type RouterMockOptions, type RouterMockSpy, type RouterMockSpyOptions, plugin as VueRouterMock, createProvide, createRouterMock, getRouter, injectRouterMock };
